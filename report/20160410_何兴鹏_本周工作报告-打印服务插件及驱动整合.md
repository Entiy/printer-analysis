#  1 本周工作

之前安卓系统打印服务的接入，以及ghostscript + foo2zjs 驱动的移植都已经完成了。所以这两周着手完成针对HP P1108打印机的打印DEMO，即整合上层接入系统打印服务部分和下层驱动。

下面详细说明工作内容。

## 1.1 确定整合方案

### 1.1.1 最简工作流程

针对HP P1108打印机的最简打印服务插件整个工作流程是：

1. 从系统获取打印任务（包含打印要求和pdf格式的待打印数据）

2. 将待打印文件保存到app空间内

3. gs读取文件转换为pbm文件

4. foo2zjs读取gs转换后的pbm文件，并转换为要输送给打印机的数据

5. 把数据输送给USB接口的打印机

### 1.1.2 分析

之前已经分别制作好了各个步骤的功能。但是这些功能并不都是在JAVA应用层面，所以需要一些适配。

步骤1 及 2 没问题，都是在应用层面，直接可用。

对于3、4 步骤，之前都是在命令行里操作。所以我们需要从应用里调用命令行，与之交互。JAVA提供了这样的功能，做了实验也通过了。

对于 步骤5 我花了大量时间。

之前测试静态编译的驱动时，直接在root权限下操作，当然不会遇到任何权限问题。

虽然之前初步调研过，认为权限问题不是很大。但在实际操作时，遇到了问题。

问题原因：由于android_x86中，系统不会自动生成设备节点（一个字符设备，名字通常叫做lp0）。

foo2zjs驱动把数据输送给该打印机的设备节点，实现打印。所以我们需要这个设备节点。（后面解决过程中发现了这个设备节点的“本质”）

另外cups是不是通过这个设备节点工作，还有待调查，到时候能不能直接用，待cups加入时再说。

之前的方法是利用busybox工具里的mdev命令，手动生成设备节点。但是实验发现非root用户不能够生成。调查发现这里面主要是利用mknod系统调用创建一个字符设备。而mknod必须要root用户才能够使用。之前没有意识到这一点。

关于为什么不向系统申请root权限来完成操作，我的原因如下：

* 一个系统为了安全性，很可能不会root。

* 把应用作为系统应用，也是没有root权限的，系统应用属于system用户组。所以系统应用也执行不了这些操作。

* 作为一个应用，尽量少做影响系统的事

如果之后实在需要执行root权限才能做的操作，我们可能会通过修改系统代码，把相关操作放入系统中，来避免我们的应用需要root权限。这个得之后再说，目前的阶段可以不需要，下面会说明。

### 1.1.3 USB接口接入方案

通过查找资料，总结了如下两个接入方案：

1     使用android usb API

通过android usb host API将usb端口转出来，生成类似字符设备（可能是管道），实现接入驱动

缺点：暂时对usb没有深入了解。

优点：通用性强，android5.1及以上任何衍生版本都可用，无需改动系统

2     使用mknod

使用root权限，通过mknod（mdev）生成设备节点，接入驱动

缺点：需要root权限，或者修改系统源码（就无需root），不方便。

优点：实现容易。

结论：根据目前掌握的资料，准备使用方案1，先进行尝试。

下面介绍这个问题的解决。

## 1.2 解决USB连接问题

为了实验方案1，首先去android reference学习了android中的USB HOST相关的接口。因为打印机接入系统，我们的系统是作为HOST方。而不是像android手机一样接入电脑，作为一个从设备。

之后，制作了USB HOST测试DEMO，实现USB设备信息的读取。

### 1.2.1 USB里的概念

了解到一个USB设备插入，首先最大的一个概念是接口（Interface）。一个USB设备接入可能会生成不只一个接口，每个接口完成各自的功能。

经过试验，发现HP P1108打印机接入，会产生两个接口，名字分别为 Printer 和 HP EWS 。看到这两个接口的名称就很明确了。Printer肯定就是我们需要的，完成打印功能的接口。第二个HP EWS，它其实是一种打印服务器，能使自己变成网络打印机。但是HP P1108打印机并没有网络接口，所以对于HP P1108打印机，这个功能被阉割了，没用。

接口下面一层是端点（Endpoint）。USB是一种串行设备，端点就相当于串口中一条通道。里面有专门发控制命令的，有发数据的。接口的功能就靠里面的端点来实现。

对于printer接口，里面生成了两个端点，都是BULK类型。也就是用于数据传送的端点，正好一个是IN一个是OUT。这和串口太像了，几乎一样。

> 一个USB2.0接口物理上只有4根线，两根还被供电用了。剩下的两个能提供这么多功能，这里跟网络很像。电脑接入网络，却有上万个端口。USB这里也是一样，每个端点都有独一无二的地址，通过地址就能访问对应的端点。所以这些应该都是逻辑上的（猜测）。

### 1.2.2 尝试发送数据

我在尝试方案1之前，就想是不是可以直接把数据发送过去。现在看到了“串口”，就直接尝试发送数据。

经过数次尝试，修改，最后成功了。

过程中，没有成功的一个主要原因是，端点的缓存有限，直接发送大量数据会造成丢失。

端点有个属性 mMaxPacketSize ，这里的值是512。所以每次发送的数据不能超过512字节，超过了就会丢失。还有一种选择，就是采用异步发送的方式（没测试）。我这里直接使用同步发送，所以不能超过512字节，需要分批发送。

android 并没有帮助辅助处理，很明显 android 是直接把USB接口暴露给了应用，应用的可操作性很大。

期间，我参考《LINUX设备驱动程序》这本书，希望从中得到有用的知识（USB和字符设备的关系）。我发现 android 对USB接口只进行了简单的封装，暴露的数据基本和LINUX里的一样（初步判断）。所以我说应用对其可操作性大，这也是成功的关键。

### 1.2.3 由USB打印机生成的字符设备浅探

在桌面Linux中，USB打印机接入系统，会自动在/dev/usb/目录生成lp0设备节点（字符设备节点）。

因为我对USB不了解，以及字符设备学习不多，所以很奇怪之间的关系。

在上学期的Linux课中，我们学习过创建一个字符设备。Linux中的字符设备其实就是一个文件，它有open、read、write等等普通文件都有的操作。

USB设备根据上面的实验了解到，它类似串口，是可读可写的。很可能read该字符设备时，系统就是直接从USB的一个端点读取数据。

根据对Printer接口的实验，我们初步印证了这个说法。对于HP P1108打印机，USB接口生成的字符设备，就是操作Printer接口里的两个端点。两个端点正好分别和read、write相对应。

所以这个lp0字符设备节点挂载的驱动，那一系列operation，就是直接操作USB端点的。目前知道的，这个字符设备做的工作有一点：缓存数据，分批发送。

我想在linux内核代码里找到这个驱动，但是还没找到。因此，这只是实验得到的结论，还没从源码里得到证实。

另外，从《LINUX设备驱动程序》中得知，在linux内核中，USB驱动程序作为基础一层。在它的上面有VFS层、块设备层、网络设备层、字符设备层等等。

```

                 用户
                  ↑
                  ↓
------------------------------------------
| VFS层 | 块设备层 | 网络设备层 | 字符设备层 |
------------------------------------------
|           USB设备驱动程序                |           内核中
------------------------------------------
|              USB核心                    |
------------------------------------------
|            USB主控制器                   |
------------------------------------------
                  ↑
                  ↓
                 硬件
                 
```

所以需要字符设备程序对USB设备进行包装（包括前面说的分批发送数据），用户是无法直接使用USB设备的，得借助生成的这些上层设备。

# 2 下周工作

## 2.1 整合

能预见到的技术困难基本都是上面说的，也都解决了。所以下面大的问题基本没有了，只需要接着完成工作。具体遇到其他问题，再解决。