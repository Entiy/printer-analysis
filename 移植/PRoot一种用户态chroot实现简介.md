# 1 前言

PRoot是我们在部署CUPS过程使用的工具。先简要介绍PRoot。

# 2 介绍

PRoot项目地址: https://github.com/proot-me/PRoot 

## 2.1 简介

PRoot是一种chroot的用户态开源实现工具。

用户不需要拥有系统特权就可以在任意目录建立一个新的根文件系统。从而在建立的根文件系统内做任何事情。

借助QEMU user-mode甚至能够运行其他CPU构架的程序。开发者也能够在PRoot中开发自己的特性。

从技术上来说，PRoot是依靠ptrace机制实现的。ptrace允许程序在没有拿到系统特权（root）时，父进程观察并修改子进程的系统调用。

## 2.2 关联真实系统文件

PRoot中建立的新的根文件系统（guest rootfs），可以用来允许一个新的Linux发行版本。

默认情况下，PRoot限制用户，只能在里面执行客户系统的程序。但是，用户可以通过内置的 mount/bind 功能，将真实系统中的文件和目录关联到客户系统里面。

并且，关联之后，从客户系统来看，就像自身的文件。

## 2.3 执行非兼容CPU构架程序

当建立的根文件系统中的Linux系统是另一个CPU构架，和当前CPU构架不兼容时，PRoots使用QEMU user-mode模拟器来执行这个客户系统。

对于要测试其他系统的软件开发者来说，这是一种很方便的方法。这种无缝连接，程序就像运行在一个本地环境。这样可以避免交叉编译的问题。

# 3 在项目中使用

## 3.1 好处一 可以把移植的程序放在任意路径

我们使用PRoot主要是因为CUPS等软件运行时路径是绝对路径，我们需要编译时指定路径才行。

比如cupsd运行的默认路径是/usr/sbin/，我们使用PRoot就可以把文件放在任意路径。

如果不使用PRoot，我们可能需要修改路径类似这样：/data/data/com.github.openthos.printer.testexec/files/cups/usr/sbin/

/data/data是安卓的应用默认的数据存储路径，应用没有权限读写根目录。

## 3.2 好处二 减少工作量，避免更多错误

还有个好处，所有的程序，包括foo2zjs驱动在静态编译移植时，使用默认路径即可，不需要一个个操作。

还能避免比如配置文件位置不正确等问题，或者要求读写/etc等目录的权限问题。

## 3.3 对USB设备读写的处理

通过把真实系统中的/dev /sys路径连接到建立的根文件系统中即可成功操作USB设备。

## 3.4 使用的命令参数

`pwd`/proot-x86-2 -w / -r `pwd` -b /dev -b /sys -b /proc

-w 指定初始时的工作路径，当然我们得把路径模拟为 /

-r 指定文件系统的位置，我们这里就是当前路径

-b 代表连接真实系统中的目录和文件到虚拟系统中。

## 3.5 bash处理

我们使用busybox工具集来实现linux shell的系统命令，包括bash。

## 3.6 临时文件夹问题

由于proot程序需要一个tmp文件夹，默认位置是在/tmp，所以需要修改位置。

master下的程序是没有这个功能，但是next分支的程序可以修改临时文件夹的位置，所以我们使用的是next分支的程序。

输出环境变量 export PROOT_TMPDIR=`pwd`/tmp 即可。